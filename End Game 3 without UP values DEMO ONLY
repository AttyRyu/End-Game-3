using System;
using System.Linq;
using cAlgo.API;
using cAlgo.API.Indicators;
using cAlgo.API.Internals;
using cAlgo.Indicators;
using System.Collections;
using System.IO;

namespace cAlgo.Robots
{
    [Robot(TimeZone = TimeZones.SingaporeStandardTime, AccessRights = AccessRights.FullAccess)]
    public class EndGame3HolyGrailDEMO : Robot
    {
        [Parameter("Nuke TP", DefaultValue = 3)]
        public double NukeTP { get; set; }

        [Parameter("Limit Range", DefaultValue = 3)]
        public double LimitRange { get; set; }

        //RSI parameters
        [Parameter("Source")]
        public DataSeries Source { get; set; }

        [Parameter("RSI Upper Limit", DefaultValue = 75)]
        public double RSIUpperLimit { get; set; }

        [Parameter("RSI Lower Limit", DefaultValue = 25)]
        public double RSILowerLimit { get; set; }

        private RelativeStrengthIndex rsim15;
        private RelativeStrengthIndex rsih1;
        //end of RSI parameter

        private MarketSeries m15;
        private AverageTrueRange ATRm15;
        private MarketSeries h1;
        private AverageTrueRange ATRh1;
        private MarketSeries h4;
        private AverageTrueRange ATRh4;
        private MarketSeries h12;
        private AverageTrueRange ATRh12;
        private MarketSeries d1;
        private AverageTrueRange ATRd1;
        private MarketSeries w1;
        private AverageTrueRange ATRw1;
        private MarketSeries m1;
        private AverageTrueRange ATRm1;

        bool timeprotected = true;
        // if true ;Expiry YEAR MM DD
        DateTime expirytime = new DateTime(2019, 8, 22);

        protected override void OnStart()
        {
            {
                if (Account.IsLive)
                {
                    Print("This is a live account, AI Maru cannot run here. For the live version, please contact ryanoia@gmail.com");
                    Stop();
                }
                else
                {
                    Print("This is a demo account and AI Maru is running. For the live version, please contact ryanoia@gmail.com");
                }

                //ATR m15, h1, h4, h12, d1, w1, m1
                m15 = MarketData.GetSeries(TimeFrame.Minute15);
                ATRm15 = Indicators.AverageTrueRange(m15, 120, MovingAverageType.Simple);
                h1 = MarketData.GetSeries(TimeFrame.Hour);
                ATRh1 = Indicators.AverageTrueRange(h1, 120, MovingAverageType.Simple);
                h4 = MarketData.GetSeries(TimeFrame.Hour4);
                ATRh4 = Indicators.AverageTrueRange(h4, 60, MovingAverageType.Simple);
                h12 = MarketData.GetSeries(TimeFrame.Hour12);
                ATRh12 = Indicators.AverageTrueRange(h12, 60, MovingAverageType.Simple);
                d1 = MarketData.GetSeries(TimeFrame.Daily);
                ATRd1 = Indicators.AverageTrueRange(d1, 30, MovingAverageType.Simple);
                w1 = MarketData.GetSeries(TimeFrame.Weekly);
                ATRw1 = Indicators.AverageTrueRange(w1, 12, MovingAverageType.Simple);
                m1 = MarketData.GetSeries(TimeFrame.Monthly);
                ATRm1 = Indicators.AverageTrueRange(m1, 3, MovingAverageType.Simple);
                //ATR m15, h1, h4, h12, d1, w1, m1

                //RSI
                rsim15 = Indicators.RelativeStrengthIndex(m15.Close, 14);
                rsih1 = Indicators.RelativeStrengthIndex(h1.Close, 14);
                //end of RSI 
            }
        }
        protected override void OnBar()
        {
            Print("Spread " + Symbol.Spread / Symbol.PipSize);
        }

        protected override void OnTick()
        {
            if (timeprotected == true && DateTime.Compare(Server.Time.Date, expirytime) >= 1)
            {
                Print("AI Maru Expired!! Please contact ryanoia@gmail.com");
                Stop();
            }
            else
            {
                //holy grail
                if ((Positions.Find("", SymbolName, TradeType.Buy) == null) && (Positions.Find("", SymbolName, TradeType.Sell) == null) && (Positions.Find("Wave 0", SymbolName, TradeType.Buy) == null) && (Positions.Find("Wave 0", SymbolName, TradeType.Sell) == null) && (Symbol.Spread / Symbol.PipSize < LimitRange) && (Server.Time.Hour != 4) && (Server.Time.Hour != 5) && (Server.Time.Hour != 6) && ((rsim15.Result.LastValue >= 40) && (rsim15.Result.LastValue <= 60)))
                {
                    CancelPendingOrders();
                    ExecuteMarketOrder(TradeType.Buy, Symbol, 1000, "Wave 0", Math.Round(ATRd1.Result.LastValue / Symbol.PipSize) * 10, Math.Round(ATRh4.Result.LastValue / Symbol.PipSize), LimitRange);
                    ExecuteMarketOrder(TradeType.Sell, Symbol, 1000, "Wave 0", Math.Round(ATRd1.Result.LastValue / Symbol.PipSize) * 10, Math.Round(ATRh4.Result.LastValue / Symbol.PipSize), LimitRange);
                    CreateWaves(TradeType.Buy);
                    CreateWaves(TradeType.Sell);
                }
                //end of holy grail

                //nuking logic
                foreach (var position in Positions)
                {
                    if ((position.TradeType == TradeType.Buy) && (position.Pips <= Math.Round(ATRw1.Result.LastValue / Symbol.PipSize) * -1) && (position.SymbolName == Symbol.Name) && (Symbol.Spread / Symbol.PipSize < LimitRange) && (rsim15.Result.LastValue < RSILowerLimit) && (Server.Time.Hour != 4) && (Server.Time.Hour != 5) && (Server.Time.Hour != 6))
                    {
                        ModifyPosition(position, 1000 * Math.Round((position.Pips * -1) / (ATRh12.Result.LastValue / Symbol.PipSize) + 0.5));
                        ModifyPosition(position, position.EntryPrice - ATRd1.Result.LastValue * 10, position.EntryPrice + NukeTP * Symbol.PipSize);
                    }
                    if ((position.TradeType == TradeType.Sell) && (position.Pips <= Math.Round(ATRw1.Result.LastValue / Symbol.PipSize) * -1) && (position.SymbolName == Symbol.Name) && (Symbol.Spread / Symbol.PipSize < LimitRange) && (rsim15.Result.LastValue > RSIUpperLimit) && (Server.Time.Hour != 4) && (Server.Time.Hour != 5) && (Server.Time.Hour != 6))
                    {
                        ModifyPosition(position, 1000 * Math.Round((position.Pips * -1) / (ATRh12.Result.LastValue / Symbol.PipSize) + 0.5));
                        ModifyPosition(position, position.EntryPrice + ATRd1.Result.LastValue * 10, position.EntryPrice - NukeTP * Symbol.PipSize);
                    }
                }
                //end of nuking logic

                //Margin Level Stop-Out alert
                if (Account.MarginLevel <= 50000)
                {
                    Print(" Margin Level = " + Account.MarginLevel + SymbolName);
                }
                //end of Margin Level Stop-Out

                //Below 200USD alert
                if (Account.UnrealizedNetProfit <= -200)
                {
                    Print(SymbolName + " Net Profit = " + Account.UnrealizedNetProfit);
                }
                if (Account.UnrealizedNetProfit <= -400)
                {
                    Print(SymbolName + " Net Profit = " + Account.UnrealizedNetProfit);
                }
                if (Account.UnrealizedNetProfit <= -600)
                {
                    Print(SymbolName + " Net Profit = " + Account.UnrealizedNetProfit);
                }
                if (Account.UnrealizedNetProfit <= -800)
                {
                    Print(SymbolName + " Net Profit = " + Account.UnrealizedNetProfit);
                }
                if (Account.UnrealizedNetProfit <= -1000)
                {
                    Print(SymbolName + " Net Profit = " + Account.UnrealizedNetProfit);
                }
                if (Account.UnrealizedNetProfit <= -1200)
                {
                    Print(SymbolName + " Net Profit = " + Account.UnrealizedNetProfit);
                }
                if (Account.UnrealizedNetProfit <= -1400)
                {
                    Print(SymbolName + " Net Profit = " + Account.UnrealizedNetProfit);
                }
                if (Account.UnrealizedNetProfit <= -1600)
                {
                    Print(SymbolName + " Net Profit = " + Account.UnrealizedNetProfit);
                }
                if (Account.UnrealizedNetProfit <= -1800)
                {
                    Print(SymbolName + " Net Profit = " + Account.UnrealizedNetProfit);
                }
                if (Account.UnrealizedNetProfit <= -2000)
                {
                    Print(SymbolName + " Net Profit = " + Account.UnrealizedNetProfit);
                }
                //end of below 200USD alert

                //big volume alert

                foreach (var position in Positions)
                {
                    if (position.VolumeInUnits >= 100000)
                    {
                        Print(SymbolName + " Volume = " + position.VolumeInUnits + " Exceeds Max Leverage 1:100 ");
                    }
                    if (position.VolumeInUnits >= 200000)
                    {
                        Print(SymbolName + " Volume = " + position.VolumeInUnits + " Exceeds Max Leverage 1:100 ");
                    }
                    if (position.VolumeInUnits >= 300000)
                    {
                        Print(SymbolName + " Volume = " + position.VolumeInUnits + " Exceeds Max Leverage 1:100 ");
                    }
                    if (position.VolumeInUnits >= 400000)
                    {
                        Print(SymbolName + " Volume = " + position.VolumeInUnits + " Exceeds Max Leverage 1:100 ");
                    }
                    if (position.VolumeInUnits >= 500000)
                    {
                        Print(SymbolName + " Volume = " + position.VolumeInUnits + " Exceeds Max Leverage 1:100 ");
                    }
                }
            }
        }

        //waves
        private void CreateWaves(TradeType type)
        {
            double TargetPrice = type == TradeType.Buy ? Symbol.Ask : Symbol.Bid;
            for (int i = 0; i < Math.Round((Math.Round(ATRw1.Result.LastValue / Symbol.PipSize) / ((Math.Round(ATRh4.Result.LastValue / Symbol.PipSize) + LimitRange)))); i++)
            {
                TargetPrice = type == TradeType.Buy ? TargetPrice + ((Math.Round(ATRh4.Result.LastValue / Symbol.PipSize) * Symbol.PipSize) + (LimitRange * Symbol.PipSize)) : TargetPrice - ((Math.Round(ATRh4.Result.LastValue / Symbol.PipSize) * Symbol.PipSize) + (LimitRange * Symbol.PipSize));
                PlaceStopLimitOrderAsync(type, Symbol, 1000, TargetPrice, LimitRange, "", Math.Round(ATRd1.Result.LastValue / Symbol.PipSize) * 10, Math.Round(ATRh4.Result.LastValue / Symbol.PipSize), null);
            }
        }
        //end of waves

        //Cancel Orders terms
        private void CancelPendingOrders()
        {
            foreach (var order in PendingOrders)
            {
                if (order.SymbolCode == Symbol.Name)
                {
                    CancelPendingOrderAsync(order);
                }
            }
        }

        private void CancelPendingBuyOrders()
        {
            foreach (var order in PendingOrders)
            {
                if ((order.SymbolCode == Symbol.Name) && (order.TradeType == TradeType.Buy))
                {
                    CancelPendingOrderAsync(order);
                }
            }
        }

        private void CancelPendingSellOrders()
        {
            foreach (var order in PendingOrders)
            {
                if ((order.SymbolCode == Symbol.Name) && (order.TradeType == TradeType.Sell))
                {
                    CancelPendingOrderAsync(order);
                }
            }
        }
        //end of Cancel Orders terms
    }
}
